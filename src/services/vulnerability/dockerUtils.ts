import Dockerode, { ContainerCreateOptions } from 'dockerode';
import { execSync } from 'child_process';
import { statSync } from 'fs';
import { ToolManager } from '../../ai/tools/ToolManager';
import { ToolContext } from '../../ai/tools/ToolTypes';

export const TOOL_EXECUTE_SHELL = 'execute_shell';

export const isRunningInDocker = (): boolean => {
  const result = statSync('/.dockerenv', { throwIfNoEntry: false });
  return result !== undefined;
};

export const runInDocker = async (
  context: ToolContext,
  image: string,
  containerCreateOpts: ContainerCreateOptions,
  ...args: string[]
): Promise<string> => {
  if (isRunningInDocker()) {
    return executeShell(context, true, ...args);
  }

  let result;
  let container: Dockerode.Container | undefined = undefined;
  const workspaceFolder = context.workspaceFolder;

  try {
    console.info(`Exectute in Docker ${image}: ${args.join(' ')}`);
    const opts = {
      ...containerCreateOpts,
      Image: image,
      Cmd: args,
    };

    const docker = new Dockerode();
    container = await docker.createContainer(opts);
    await container.start();

    const { output } = await container.wait();
    // container.logs({ follow: true, stderr: true, stdout: true }, (err, stream) => {
    //   if (err) {
    //     console.error('Error streaming logs:', err);
    //     return;
    //   }
    //   stream!.pipe(process.stdout);
    // });
    // console.info('Execution output:', output);
    //
    // const logs = await container.logs({ stdout: true, stderr: true, follow: true });
    const logs = await container.logs({ stdout: true, stderr: true });
    result = logs.toString('utf-8');

    // return new Promise((resolve, reject) => {
    //   container!.logs(
    //     {
    //       follow: true,
    //       stdout: true,
    //       stderr: false,
    //     },
    //     (err, stream) => {
    //       if (err) {
    //         return reject(err);
    //       }

    //       let logData = '';

    //       if (!stream) {
    //         return reject(new Error('No log stream'));
    //       }

    //       stream.on('data', (chunk) => {
    //         // Docker log streams prefix each frame with an 8-byte header.
    //         // The first 4 bytes are the stream type, and the next 4 bytes are the payload size.
    //         // We start reading the payload from byte 8 onwards to skip this header.
    //         const start = 8;
    //         const length = chunk.readUInt32BE(4);
    //         const logText = chunk.slice(start, start + length).toString('utf8');

    //         logData += logText;
    //       });

    //       stream.on('end', () => {
    //         console.info('Log stream ended');
    //         resolve(logData);
    //       });

    //       stream.on('error', (streamErr) => {
    //         reject(streamErr);
    //       });
    //     },
    //   );
    // });
    // result = await readFile('/results.json');
  } catch (err) {
    console.error('Failed to run in Docker:', err);
    result = executeShell(context, false, ...args);
  } finally {
    if (container !== undefined) {
      try {
        await container.stop();
      } catch {}
      await container.remove();
    }
  }

  return result;
};

export const executeShell = async (
  context: ToolContext,
  alreadyInDocker: boolean,
  ...args: string[]
): Promise<string> => {
  const command = args.join(' ');
  if (!alreadyInDocker) {
    // TODO: implement allow/deny list as per validate_command in AutoGPT
    if (!(await context.askForUserPermission(`Can I run "${command}"?`))) {
      return 'Command rejected by user';
    }
    console.info(`Running locally: ${command}`);
  }
  return execSync(command, { cwd: context.workspaceFolder, encoding: 'utf-8' });
};

ToolManager.registerTool(executeShell, {
  name: TOOL_EXECUTE_SHELL,
  description: 'Execute a Shell Command, non-interactive commands only',
  parameters: {
    type: 'object',
    properties: {
      command_line: {
        type: 'string',
        description: 'The command line to execute',
      },
    },
    required: ['command_line'],
  },
});
